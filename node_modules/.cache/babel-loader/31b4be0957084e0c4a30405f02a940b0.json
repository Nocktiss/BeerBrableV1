{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = undefined;\n\nvar _identity = require('ramda/src/identity');\n\nvar _identity2 = _interopRequireDefault(_identity);\n\nvar _map = require('ramda/src/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _reduce = require('ramda/src/reduce');\n\nvar _reduce2 = _interopRequireDefault(_reduce);\n\nvar _curry = require('ramda/src/curry');\n\nvar _curry2 = _interopRequireDefault(_curry);\n\nvar _filter = require('ramda/src/filter');\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _equals = require('ramda/src/equals');\n\nvar _equals2 = _interopRequireDefault(_equals);\n\nvar _all = require('ramda/src/all');\n\nvar _all2 = _interopRequireDefault(_all);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n *\n * @param {Function} successFn callback function in case of valid input\n * @param {Function} failFn callback function in case of invalid input\n * @param {Array} input\n * @returns {*}\n */\n\n\nvar transform = function transform(successFn, failFn, input) {\n  var valid = (0, _all2.default)((0, _equals2.default)(true), input);\n  return valid ? successFn() : failFn((0, _filter2.default)(function (a) {\n    return a !== true;\n  }, input));\n};\n/**\n *\n * @param {Function} predicate validation function to apply inputs on\n * @param {String|Function} errorMsg error message to return in case of fail\n * @param {*} value the actual value\n * @param {Object} inputs the input object - in case the predicate function needs access to dependent values\n * @returns {Boolean}\n */\n\n\nvar runPredicate = function runPredicate(_ref, value, inputs, field) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      predicate = _ref2[0],\n      errorMsg = _ref2[1];\n\n  return predicate(value, inputs // eslint-disable-line no-nested-ternary\n  ) ? true : typeof errorMsg === 'function' ? errorMsg(value, field) : errorMsg;\n};\n/**\n *\n * @param {Function} successFn callback function in case of valid input\n * @param {Function} failFn callback function in case of invalid input\n * @param {Object} spec the rule object\n * @param {Object|Function} input the validation input data\n * @returns {{}}\n */\n\n\nvar validate = exports.validate = (0, _curry2.default)(function (successFn, failFn, spec, input) {\n  var inputFn = typeof input === 'function' ? input : function (key) {\n    return key ? input : input;\n  };\n  var keys = Object.keys(inputFn());\n  return (0, _reduce2.default)(function (result, key) {\n    var inputObj = inputFn(key);\n    var value = inputObj[key];\n    var predicates = spec[key];\n\n    if (Array.isArray(predicates)) {\n      return _extends({}, result, _defineProperty({}, key, transform(function () {\n        return successFn(value);\n      }, failFn, (0, _map2.default)(function (f) {\n        return runPredicate(f, value, inputObj, key);\n      }, predicates))));\n    } else if ((typeof predicates === 'undefined' ? 'undefined' : _typeof(predicates)) === 'object') {\n      return _extends({}, result, _defineProperty({}, key, validate(successFn, failFn, predicates, value)));\n    } else if (typeof predicates === 'function') {\n      var rules = predicates(value);\n      return _extends({}, result, _defineProperty({}, key, validate(successFn, failFn, rules, value)));\n    } else {\n      return _extends({}, result, _defineProperty({}, key, successFn([])));\n    }\n  }, {}, keys);\n}\n/**\n *\n * @param {Object} spec the rule object\n * @param {Object} input the validation input data\n * @returns {{}}\n */\n);\nvar spected = validate(function () {\n  return true;\n}, _identity2.default);\nexports.default = spected;","map":null,"metadata":{},"sourceType":"script"}